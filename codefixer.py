import copy
import re

from utils.codefixfuncs import *
from utils.fixertree import *
from pycparser import parse_file

if __name__ == '__main__':
    original_file_name = 'compare1.cpp'
    original_file_path = 'codegenerate/codes/' + original_file_name
    fixed_file_path = 'fixedfiles/fix_' + original_file_name

    file_path = 'tempfiles/tempfile.cpp'
    # 去掉头
    file_head_list = []
    with open(original_file_path, 'r') as f:
        original_file_lines = f.readlines()
    for line_num in range(len(original_file_lines)):
        if original_file_lines[line_num].find("#include") >= 0:
            file_head_list.append({
                "line_num": line_num,
                "content": original_file_lines[line_num]
            })
            original_file_lines[line_num] = "\n"
    with open(file_path, 'w') as f:
        f.writelines(original_file_lines)

    ast = parse_file(file_path, use_cpp=True, cpp_path=r'C:\IDE\Dev-Cpp\MinGW64\bin\gcc.exe',
                     cpp_args=['-E', r'-Iutils/fake_libc_include'])
    xml_root = convert_node_to_xml(ast)
    xml_tree = ET.ElementTree(xml_root)
    xml_tree.write('output.xml', encoding='utf-8', xml_declaration=True)
    root = xml_tree.getroot()

    # 准备修改的文件
    with open(file_path, 'r') as f:
        file_lines = f.readlines()

    # 存储修改步骤的列表
    fix_step_list = []
    fix_offset = 0

    # Structures need to be detected
    rule_list = [
        ["For", "If", "Return"],
        ["While", "If", "Return"],
        ["DoWhile", "If", "Return"],
        ["For", "If", "Break"],
        ["While", "If", "Break"],
        ["DoWhile", "If", "Break"],
        ["For", "Switch", "Return"],
        ["While", "Switch", "Return"],
        ["DoWhile", "Switch", "Return"],
        ["For", "If", "Goto"],
        ["While", "If", "Goto"],
        ["DoWhile", "If", "Goto"]
    ]

    tree_list = []
    vul_flag = 0

    for rule in rule_list:
        # Based on the structure, build a tree in the code that satisfies the structure
        new_tree = build_tree(root, rule)
        tree_list.append(new_tree)

    for i in range(3, 12):
        log_temp_list = []
        # Search all paths in the tree
        current_path_list = find_paths(tree_list[i])
        for j in current_path_list:
            if len(j) == len(rule_list[i]) + 1:  # Skip the root node of the tree
                lines = []
                for path_element in j:
                    # get line number of the corresponding structure
                    lines.append(path_element.get("line"))
                log_temp_list.append(f"found at lines {lines[1:]}")
                # print(f"found at lines {lines[1:]}")
        # Output log when the structure is detected
        if len(log_temp_list) > 0:
            vul_flag += 1
            print(f"Detected vulnerable structure {rule_list[i]}:")
            for log in log_temp_list:
                print(log)
            print(
                f"In a {rule_list[i][0]} structure: {rule_list[i][1]}-{rule_list[i][2]} structure may may make the program run time inconsistent, you are advised to delete this structure.")
            print("-----------------------------")

    # Fix if return
    for i in range(3):
        log_temp_list = []
        # Search all paths in the tree
        current_path_list = find_paths(tree_list[i])
        for j in current_path_list:
            if len(j) == len(rule_list[i]) + 1:  # Skip the root node of the tree
                lines = []
                for path_element in j:
                    # get line number of the corresponding structure
                    lines.append(path_element.get("line"))
                log_temp_list.append(f"found at lines {lines[1:]}")
                # 取出return的是什么
                return_value = re.search(r'return (.*?);', file_lines[int(lines[3]) - 1]).group(1)
                # 增加修改建议
                # for 之前添加
                fix_step_list.append({
                    'note': "insert_before_line",
                    'line': int(lines[1]),
                    'value': "int autoFixValue = " + return_value + ";int autoFixLock = 0;\n"
                })
                # for 之后添加
                fix_step_list.append({
                    'note': "insert_after_line",
                    'line': find_end_line(file_lines, int(lines[1])),
                    'value': "if (autoFixLock==1){return autoFixValue;}\n"
                })
                # replace return
                fix_step_list.append({
                    'note': "replace",
                    'line': int(lines[3]),
                    'value': "{autoFixValue = autoFixLock * autoFixValue + (1-autoFixLock) * " + return_value + ";autoFixLock = 1;}\n"
                })
                # print(f"found at lines {lines[1:]}")
        # Output log when the structure is detected
        if len(log_temp_list) > 0:
            vul_flag += 1
            print(f"Detected vulnerable structure {rule_list[i]}:")
            for log in log_temp_list:
                print(log)
            print(
                f"In a {rule_list[i][0]} structure: {rule_list[i][1]}-{rule_list[i][2]} structure may may make the program run time inconsistent, you are advised to delete this structure.")
            print("-----------------------------")

    if vul_flag == 0:
        print("No vulnerability detected!")

    # 排列需要修改的行
    sorted_fix_step_list = sorted(fix_step_list, key=lambda d: d['line'])

    # print(fix_step_list)
    # print(sorted_fix_step_list)

    for step in sorted_fix_step_list:
        if step['note'] == 'insert_before_line':
            fix_offset, file_lines = insert_before_line(file_lines, step['line'], fix_offset, step['value'])
        elif step['note'] == 'insert_after_line':
            fix_offset, file_lines = insert_after_line(file_lines, step['line'], fix_offset, step['value'])
        elif step['note'] == 'replace':
            fix_offset, file_lines = delete_line(file_lines, step['line'], fix_offset)
            fix_offset, file_lines = insert_after_line(file_lines, step['line'], fix_offset, step['value'])

    if len(sorted_fix_step_list) > 0:
        print(f"Fixed file saved at: {fixed_file_path}")
        # 还原文件头
        for file_head in file_head_list:
            file_lines[file_head["line_num"]] = file_head["content"]
        with open(fixed_file_path, 'w') as f:
            f.writelines(file_lines)

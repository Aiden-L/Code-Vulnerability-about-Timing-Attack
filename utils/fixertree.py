from pycparser import c_ast
import xml.etree.ElementTree as ET

def convert_node_to_xml(node):
    # Create XML element
    xml_element = ET.Element(node.__class__.__name__)

    # Add line number information if available
    if node.coord:
        xml_element.set('line', str(node.coord.line))

    # Add attributes
    for attr_name in node.attr_names:
        attr_value = getattr(node, attr_name)
        if attr_value:
            xml_element.set(attr_name, str(attr_value))

    # Recursively process child nodes
    for child_name, child in node.children():
        if isinstance(child, list):
            for item in child:
                xml_element.append(convert_node_to_xml(item))
        elif isinstance(child, c_ast.Node):
            xml_element.append(convert_node_to_xml(child))

    return xml_element


def has_element_with_type(xml_tree, structure_name, child_structure_name):
    # Finds the child element of the corresponding structure
    parent_elements = xml_tree.findall('.//{}'.format(structure_name))

    matched_child_list = []
    matched_parent_list = []

    for parent_element in parent_elements:
        # Find child element
        child_elements = parent_element.findall('.//{}'.format(child_structure_name))
        if child_elements:
            matched_parent_list.append(parent_element)
            for child_element in child_elements:
                matched_child_list.append(child_element)

    return matched_child_list, matched_parent_list


def find_child(parent_element, child_structure_name):
    return parent_element.findall('.//{}'.format(child_structure_name))

class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []


# 深度优先搜索，遍历树
def dfs(node):
    if node is None:
        return
    print(node.value)
    for child in node.children:
        dfs(child)


def find_paths(root, path=None, paths=None):
    if paths is None:
        paths = []
    if path is None:
        path = []
    if root is None:
        return paths
    path.append(root.value)
    if len(root.children) == 0:  # If the node is a leaf node
        paths.append(list(path))  # Adds the current path to the path list
    else:
        for child in root.children:
            find_paths(child, path, paths)
    path.pop()  # Removes the current node from the path
    return paths  # Return all paths


def build_tree(root, rule):
    # Set the root node of the file to the root node of the new tree
    tree_root = TreeNode(root)

    level_list = [tree_root]
    # Build each level of the tree according to the rules
    for rule_index in range(len(rule)):
        level_temp_list = []
        for this_level in level_list:
            # For each level, find the child node to form the next level
            temp_list = find_child(this_level.value, rule[rule_index])
            for k in temp_list:
                temp = TreeNode(k)
                this_level.children.append(temp)
                level_temp_list.append(temp)
        level_list = level_temp_list

    return tree_root
# Code-Vulnerability-about-Timing-Attack
Detection of Code Vulnerability about Timing Attack

## Preparation
### 1. Environment configuration
Environment:
- python = 3.8
- GCC = 11.4.0

Python dependencies:
```bash
pip install -r requirements.txt
```
angr installation, refer to:
[https://docs.angr.io/en/latest/analyses/cfg.html](https://docs.angr.io/en/latest/analyses/cfg.html)

```bash
cd angr-dev
git clone https://github.com/axt/bingraphvis
pip install -e ./bingraphvis
git clone https://github.com/axt/angr-utils
pip install -e ./angr-utils
```

### 2. Sample code generation
- The templates are in folder [templates](codegenerate/templates) (string comparison) and [templates2](codegenerate/templates2) (bytes comparison).
- Run scripts [createfiles.py](codegenerate/createfiles.py) with these commands:
```bash
cd codegenerate
python createfiles.py
```
- The generated codes are saved in [codes](codegenerate/codes).
- compile the code using gcc, the script for compiling all code in the folder is [compilefiles.sh](compilefiles.sh).
- This experiment is using `GCC 11.4.0` in `Ubuntu 22.04.3`.
- Put [compilefiles.sh](compilefiles.sh) and the source code folder [codes](codegenerate/codes) under the same directory.
- Make sure that `dest_folder` in [compilefiles.sh](compilefiles.sh) point to the right directory and run:
```bash
mkdir binaryfiles
bash compilefiles.sh
```
- The binary executable files will be saved in folder `binaryfiles` in the same directory with [compilefiles.sh](compilefiles.sh).
- The already compiled binary files are in folder [binaryfiles](binaryfiles).

## Experiments
### 1. Symbolic Execution Experiment
#### 1.1 Plot CFG
[angrtracetest.py](angrtracetest.py) is able to print the path that symbolic execution goes through and draw the CFG.
The output for [angrtracetest.py](angrtracetest.py) is shown below:
```bash
Number of path: 1
Address list:
['0x401080', '0x500000', '0x401204', '0x401169', '0x401060', '0x500008', '0x401191', '0x401060', '0x500008', '0x4011a0', '0x4011ac', '0x4011e4', '0x401060', '0x500008', '0x4011f6', '0x4011b5', '0x4011e0', '0x401060', '0x500008', '0x4011f6', '0x4011b5', '0x4011d9', '0x401060', '0x500008', '0x4011f6', '0x4011b5', '0x4011d9', '0x401060', '0x500008', '0x4011f6', '0x4011fb', '0x401242', '0x401070', '0x500010', '0x401258', '0x601050']
Number of blocks passed: 36
```
It indicates that there are only one path, for `str_a = "aaa"`, `str_b = "acb"` have determined. 
The addresses of each code block passed when symbolic executed this are shown in the list, with order.
(Form the [CFG](cfg_test.png) shows the code contained in these addresses and what part of the program they are in). 
There are totally 29 blocks passed in this process.

To plot cfgs of all files in [binaryfiles](binaryfiles), can run:
```bash
python cfgplot.py
```

#### 1.2 Symbolized variables, retest
Use the same principle, when symbolize str_a and str_b, as shown in [angrtrace.py](angrtrace.py)
```python
str_a_length = 10
str_b_length = 10
str_a = claripy.BVS("str_a", 8 * str_a_length)  # Each character is 8 bits
str_b = claripy.BVS("str_b", 8 * str_b_length)
```
And let the length of `str_a` be constant, the length of `str_b` is between 0 and 10

The number of blocks passed is shown in `logs/`, if different inputs make all pass the same number of code blocks, then it is time constant.

The result shows that [compare1.cpp](codegenerate/codes/compare1.cpp), [compare6.cpp](codegenerate/codes/compare6.cpp) and [compare11.cpp](codegenerate/codes/compare11.cpp) are time constant. 
This is consistent with the hypothesis. Because they have no earlier break inside the loop.

### 2. Code detection and Fixing
Run [codefixer.py](codefixer.py) to detect vulnerability and provide possible solution.

The fixed files are stored in [fixedfiles](fixedfiles). These files are also compiled and tested, the compiled binary files are
saved in [binaryfiles](binaryfiles), symbolic execution retest results are stored in [logs](logs).
